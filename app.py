
"""
=============================================================================
RESOLVEDOR DE SISTEMAS LINEARES 3D - APLICA√á√ÉO STREAMLIT
=============================================================================

Aplica√ß√£o interativa para resolu√ß√£o de sistemas de equa√ß√µes lineares 3x3
com visualiza√ß√£o 3D passo a passo do processo de elimina√ß√£o gaussiana.

Autor: Autor: Izaac Soares, Jeferson Danilo
Data: 03/08/2025
Vers√£o: 1.0

Funcionalidades:
- Entrada interativa de coeficientes
- Resolu√ß√£o passo a passo via elimina√ß√£o gaussiana
- Visualiza√ß√£o 3D dos planos geom√©tricos
- Formata√ß√£o LaTeX das matrizes
- Interface responsiva e intuitiva

Depend√™ncias:
- streamlit
- numpy
- pandas
- plotly
- linear_solver (m√≥dulo personalizado)
"""

# =============================================================================
# IMPORTA√á√ïES
# =============================================================================

import streamlit as st
import numpy as np
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
import io
import sys
import re
import itertools
from contextlib import redirect_stdout

# Importa√ß√µes do m√≥dulo personalizado
from linear_solver import (
    validar_matriz_usuario, 
    resolver_sistema_linear_passo_a_passo,
    plotar_planos_3d, 
    PLOT_CONFIG
)

# =============================================================================
# CONFIGURA√á√ÉO DA P√ÅGINA
# =============================================================================

st.set_page_config(
    page_title="Resolvedor de Sistemas Lineares 3D",
    page_icon="üî¢",
    layout="wide",
    initial_sidebar_state="expanded"
)

# =============================================================================
# CABE√áALHO PRINCIPAL
# =============================================================================

st.title("üî¢ Resolvedor de Sistemas Lineares 3x3")
st.markdown("""
### Uma aplica√ß√£o interativa para resolver sistemas de equa√ß√µes lineares com visualiza√ß√£o 3D passo a passo

Esta ferramenta permite resolver sistemas de equa√ß√µes lineares 3x3 atrav√©s do m√©todo de elimina√ß√£o gaussiana,
visualizando cada etapa do processo tanto algebricamente quanto geometricamente.
""")

# =============================================================================
# FUN√á√ïES DE FORMATA√á√ÉO E UTILIT√ÅRIOS
# =============================================================================

def formatar_matriz_latex(matriz, highlight_row_index=None):
    """
    Converte uma matriz num√©rica para representa√ß√£o LaTeX formatada.
    
    Esta fun√ß√£o cria uma matriz aumentada em nota√ß√£o LaTeX, adequada para
    sistemas de equa√ß√µes lineares, com separa√ß√£o visual entre coeficientes
    e termos independentes.
    
    Args:
        matriz (np.array or list): Matriz a ser formatada (deve ter 4 colunas)
        highlight_row_index (int, optional): √çndice da linha a destacar
        
    Returns:
        str: String formatada em LaTeX para renderiza√ß√£o matem√°tica
        
    Exemplo:
        >>> matriz = [[1, 2, 3, 4], [5, 6, 7, 8]]
        >>> print(formatar_matriz_latex(matriz))
        $$\left(\begin{array}{ccc|c} 1 & 2 & 3 & 4 \\ 5 & 6 & 7 & 8 \end{array}\right)$$
    """
    # Valida√ß√£o de entrada
    if matriz is None or len(matriz) == 0 or len(matriz[0]) == 0:
        return ""
    
    # Convers√£o para lista se necess√°rio
    matriz_list = matriz.tolist() if isinstance(matriz, np.ndarray) else matriz
    num_rows = len(matriz_list)
    num_cols = len(matriz_list[0])
    
    # Configura√ß√£o do alinhamento (separador vertical antes da √∫ltima coluna)
    alignment = 'c' * (num_cols - 1) + '|c'

    # Formata√ß√£o de cada linha
    rows_latex = []
    for i, row in enumerate(matriz_list):
        formatted_elements = []
        for elem in row:
            # Convers√£o e formata√ß√£o num√©rica
            val = float(elem)
            if np.isclose(val, int(val)):
                formatted_elements.append(str(int(val)))
            else:
                formatted_elements.append(f'{val:.1f}')
        
        row_str = ' & '.join(formatted_elements)
        rows_latex.append(row_str)
    
    # Montagem da matriz LaTeX
    matrix_body = ' \\\\ '.join(rows_latex)
    latex_string = f'$$\\left(\\begin{{array}}{{{alignment}}} {matrix_body} \\end{{array}}\\right)$$'
    
    return latex_string


def parse_step_operation(step_name):
    """
    Analisa a descri√ß√£o textual de uma opera√ß√£o matricial para extrair informa√ß√µes estruturadas.
    
    Esta fun√ß√£o usa express√µes regulares para identificar diferentes tipos de opera√ß√µes
    de elimina√ß√£o gaussiana e gerar descri√ß√µes LaTeX apropriadas.
    
    Args:
        step_name (str): Descri√ß√£o da opera√ß√£o (ex: 'L2 <- L2 - 1.0 * L1')
        
    Returns:
        tuple: (linha_alvo, linha_fonte, desc_curta, desc_longa)
               Retorna (None, None, None, None) se n√£o conseguir analisar
               
    Tipos de opera√ß√µes suportadas:
        - Combina√ß√£o linear: L_i <- L_i + c * L_j
        - Escalonamento: L_i <- c * L_i  
        - Permuta√ß√£o: L_i <-> L_j
    """
    # Padr√£o para opera√ß√µes de combina√ß√£o linear (L_i <- L_i ¬± c * L_j)
    match = re.search(r'L(\d+) <- L\d+ ([+-]) ([\d\.]+) \* L(\d+)', step_name)
    if match:
        target_row = int(match.group(1))
        sign = match.group(2)
        multiplier_val = float(match.group(3))
        source_row = int(match.group(4))
        
        # Ajuste do multiplicador baseado no sinal
        multiplier = multiplier_val if sign == '+' else -multiplier_val
        
        # Gera√ß√£o das descri√ß√µes
        desc_long = f'$L_{{{target_row}}} \\leftarrow L_{{{target_row}}} + ({multiplier}) \\cdot L_{{{source_row}}} \\iff L_{{{target_row}}} \\leftarrow L_{{{target_row}}} {sign} {multiplier_val} \\cdot L_{{{source_row}}}$'
        desc_short = f'\\times({multiplier})'
        
        return target_row, source_row, desc_short, desc_long
        
    # Padr√£o para opera√ß√µes de escalonamento (L_i <- c * L_i)
    match_scale = re.search(r'L(\d+) <- ([\d\.]+) \* L(\d+)', step_name)
    if match_scale:
        target_row = int(match_scale.group(1))
        source_row = int(match_scale.group(3))
        multiplier = float(match_scale.group(2))
        
        if target_row == source_row:
            desc_long = f'$L_{{{target_row}}} \\leftarrow {multiplier} \\cdot L_{{{target_row}}}$'
            desc_short = f'\\times({multiplier})'
            return target_row, None, desc_short, desc_long
            
    # Padr√£o para opera√ß√µes de permuta√ß√£o (L_i <-> L_j)
    match_swap = re.search(r'Troca de linhas: L(\d+) <-> L(\d+)', step_name)
    if match_swap:
        row1 = int(match_swap.group(1))
        row2 = int(match_swap.group(2))
        desc_long = f'$L_{{{row1}}} \\leftrightarrow L_{{{row2}}}$'
        desc_short = f'L_{{{row1}}} \\leftrightarrow L_{{{row2}}}'
        return row1, row2, desc_short, desc_long

    return None, None, None, None


def display_step_with_annotations(current_matriz, prev_matriz, step_info):
    """
    Exibe a transi√ß√£o entre matrizes com anota√ß√µes matem√°ticas detalhadas.
    
    Esta fun√ß√£o cria uma visualiza√ß√£o rica da transforma√ß√£o matricial,
    mostrando a matriz anterior, a opera√ß√£o aplicada e a matriz resultante
    com formata√ß√£o LaTeX adequada.
    
    Args:
        current_matriz (np.array): Matriz ap√≥s a opera√ß√£o
        prev_matriz (np.array): Matriz antes da opera√ß√£o  
        step_info (dict): Dicion√°rio com informa√ß√µes do passo
    """
    step_name = step_info['step_name']
    
    # Tratamento especial para o passo inicial
    if "In√≠cio da Elimina√ß√£o Gaussiana" in step_name:
        st.markdown("**Matriz atual:**")
        latex_matriz = formatar_matriz_latex(current_matriz)
        st.markdown(latex_matriz, unsafe_allow_html=True)
        return

    # An√°lise da opera√ß√£o
    target_row, source_row, desc_short, desc_long = parse_step_operation(step_name)

    if desc_short:
        # Formata√ß√£o das matrizes
        latex_prev_str = formatar_matriz_latex(prev_matriz).replace('$$', '')
        latex_current_str = formatar_matriz_latex(current_matriz).replace('$$', '')
        
        if source_row:
            # Exibi√ß√£o da transi√ß√£o com opera√ß√£o de combina√ß√£o linear
            st.markdown(f"""
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                <div style="font-size: 2em;">
                    {latex_prev_str}
                </div>
                <div style="text-align: center;">
                    <span style="font-size: 2em;">
                        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                    </span>
                    <br>
                    <span style="font-size: 1.5em;">
                        $L_{{{target_row}}} \\leftarrow L_{{{target_row}}} + ({desc_short}) \\cdot L_{{{source_row}}}$
                    </span>
                </div>
                <div style="font-size: 2em;">
                    {latex_current_str}
                </div>
            </div>
            """, unsafe_allow_html=True)
            
            st.markdown(f"**Opera√ß√£o:** {desc_long}")
            
        else:
            # Exibi√ß√£o para opera√ß√µes de troca ou escalonamento
            st.markdown(f"**Matriz anterior:**")
            st.markdown(formatar_matriz_latex(prev_matriz), unsafe_allow_html=True)
            st.markdown(f"**Opera√ß√£o:** {desc_long}")
            st.markdown(f"**Matriz atual:**")
            st.markdown(formatar_matriz_latex(current_matriz), unsafe_allow_html=True)
    else:
        # Fallback para opera√ß√µes n√£o reconhecidas
        st.markdown(f"**Matriz atual:**")
        st.markdown(formatar_matriz_latex(current_matriz), unsafe_allow_html=True)


def formatar_equacao_latex(a, b, c, d):
    """
    Converte coeficientes num√©ricos em uma equa√ß√£o linear formatada em LaTeX.
    
    Gera representa√ß√£o textual de uma equa√ß√£o da forma ax + by + cz = d,
    tratando casos especiais como coeficientes zero, unit√°rios e negativos.
    
    Args:
        a, b, c (float): Coeficientes das vari√°veis x, y, z
        d (float): Termo independente
        
    Returns:
        str: Equa√ß√£o formatada em LaTeX
        
    Exemplo:
        >>> formatar_equacao_latex(1, -2, 0, 5)
        'x - 2.0y = 5.0'
    """
    termos = []
    
    # Processamento do coeficiente de x
    if not np.isclose(a, 0):
        if np.isclose(abs(a), 1):
            termos.append(f"{'-' if a < 0 else ''}x")
        else:
            termos.append(f"{a:.1f}x")
    
    # Processamento do coeficiente de y
    if not np.isclose(b, 0):
        sign = ' + ' if b >= 0 and len(termos) > 0 else ' - ' if b < 0 and len(termos) > 0 else '-' if b < 0 else ''
        if np.isclose(abs(b), 1):
            termos.append(f"{sign}y")
        else:
            termos.append(f"{sign}{abs(b):.1f}y")
    
    # Processamento do coeficiente de z
    if not np.isclose(c, 0):
        sign = ' + ' if c >= 0 and len(termos) > 0 else ' - ' if c < 0 and len(termos) > 0 else '-' if c < 0 else ''
        if np.isclose(abs(c), 1):
            termos.append(f"{sign}z")
        else:
            termos.append(f"{sign}{abs(c):.1f}z")
    
    # Montagem da equa√ß√£o final
    equacao_str = "".join(termos).strip()
    if equacao_str.startswith('+'):
        equacao_str = equacao_str[1:].strip()
        
    if not equacao_str:
        return f"0 = {d:.1f}"
        
    return f"{equacao_str} = {d:.1f}"

# =============================================================================
# INTERFACE LATERAL - ENTRADA DE DADOS
# =============================================================================

st.sidebar.header('üì• Entrada de Equa√ß√µes')
st.sidebar.markdown("""
Insira os coeficientes para o sistema de equa√ß√µes lineares da forma:
- **ax + by + cz = d**

Cada equa√ß√£o representa um plano no espa√ßo 3D.
""")

# Equa√ß√£o 1
st.sidebar.markdown('**Equa√ß√£o 1:**')
cols = st.sidebar.columns([1, 0.3, 1, 0.3, 1, 0.3, 1])
a1 = cols[0].number_input('', key='a1', format='%.1f', value=1.0, label_visibility='collapsed')
cols[1].markdown('x +')
b1 = cols[2].number_input('', key='b1', format='%.1f', value=1.0, label_visibility='collapsed')
cols[3].markdown('y +')
c1 = cols[4].number_input('', key='c1', format='%.1f', value=1.0, label_visibility='collapsed')
cols[5].markdown('z =')
d1 = cols[6].number_input('', key='d1', format='%.1f', value=6.0, label_visibility='collapsed')

# Equa√ß√£o 2
st.sidebar.markdown('**Equa√ß√£o 2:**')
cols = st.sidebar.columns([1, 0.3, 1, 0.3, 1, 0.3, 1])
a2 = cols[0].number_input('', key='a2', format='%.1f', value=1.0, label_visibility='collapsed')
cols[1].markdown('x +')
b2 = cols[2].number_input('', key='b2', format='%.1f', value=-1.0, label_visibility='collapsed')
cols[3].markdown('y +')
c2 = cols[4].number_input('', key='c2', format='%.1f', value=2.0, label_visibility='collapsed')
cols[5].markdown('z =')
d2 = cols[6].number_input('', key='d2', format='%.1f', value=5.0, label_visibility='collapsed')

# Equa√ß√£o 3
st.sidebar.markdown('**Equa√ß√£o 3:**')
cols = st.sidebar.columns([1, 0.3, 1, 0.3, 1, 0.3, 1])
a3 = cols[0].number_input('', key='a3', format='%.1f', value=1.0, label_visibility='collapsed')
cols[1].markdown('x +')
b3 = cols[2].number_input('', key='b3', format='%.1f', value=-1.0, label_visibility='collapsed')
cols[3].markdown('y +')
c3 = cols[4].number_input('', key='c3', format='%.1f', value=-3.0, label_visibility='collapsed')  # Corrigido: era 'c4'
cols[5].markdown('z =')
d3 = cols[6].number_input('', key='d3', format='%.1f', value=-10.0, label_visibility='collapsed')

# =============================================================================
# PROCESSAMENTO E RESOLU√á√ÉO DO SISTEMA
# =============================================================================

st.sidebar.markdown("---")
if st.sidebar.button("üöÄ Resolver Sistema", type="primary"):
    
    # Montagem da matriz de coeficientes
    matriz_list = [
        [a1, b1, c1, d1],
        [a2, b2, c2, d2],
        [a3, b3, c3, d3]
    ]

    matriz = None
    try:
        # Convers√£o e valida√ß√£o inicial
        matriz = np.array(matriz_list, dtype=float)
        if matriz.shape != (3, 4):
            st.sidebar.warning("Por favor, insira uma matriz com 3 equa√ß√µes e 4 colunas.")
            matriz = None
    except ValueError:
        st.sidebar.error("Erro: Todos os valores da matriz devem ser num√©ricos.")
        matriz = None

    if matriz is not None:
        try:
            # Valida√ß√£o avan√ßada e resolu√ß√£o
            matriz_validada = validar_matriz_usuario(matriz)
            
            with st.spinner("Resolvendo sistema..."):
                desc, sol, steps_data, solution_point = resolver_sistema_linear_passo_a_passo(
                    matriz_validada, verbose=False
                )
            
            # Armazenamento dos resultados na sess√£o
            st.session_state['solucao_desc'] = desc
            st.session_state['solucao_valores'] = sol
            st.session_state['steps_data'] = steps_data
            st.session_state['matriz_inicial'] = matriz_validada
            st.session_state['solution_point'] = solution_point
            st.session_state['sistema_resolvido'] = True
            
        except Exception as e:
            st.sidebar.error(f"Erro ao processar matriz: {str(e)}")
            st.sidebar.info("Verifique se a matriz est√° no formato correto.")
            st.session_state['sistema_resolvido'] = False
            st.session_state['solution_point'] = None
    else:
        st.sidebar.warning("Por favor, insira os valores para as equa√ß√µes antes de resolver.")
        st.session_state['sistema_resolvido'] = False
        st.session_state['solution_point'] = None

# =============================================================================
# EXIBI√á√ÉO DOS RESULTADOS NA BARRA LATERAL
# =============================================================================

if 'sistema_resolvido' in st.session_state and st.session_state['sistema_resolvido']:
    st.sidebar.markdown("---")
    st.sidebar.header("üìã Resultado:")

    desc = st.session_state['solucao_desc']
    sol = st.session_state['solucao_valores']

    # Classifica√ß√£o do sistema com √≠cones apropriados
    if "imposs√≠vel" in desc.lower():
        st.sidebar.error(f"‚ùå {desc}")
        st.sidebar.markdown("**Sistema Imposs√≠vel (SI):** N√£o existe solu√ß√£o que satisfa√ßa todas as equa√ß√µes simultaneamente.")
    elif "indeterminado" in desc.lower():
        st.sidebar.warning(f"‚ö†Ô∏è {desc}")
        st.sidebar.markdown("**Sistema Indeterminado (SPI):** Existem infinitas solu√ß√µes poss√≠veis.")
    else:
        st.sidebar.success(f"‚úÖ {desc}")
        st.sidebar.markdown("**Sistema Determinado (SPD):** Existe uma √∫nica solu√ß√£o.")

    # Exibi√ß√£o das solu√ß√µes (se existirem)
    if len(sol) > 0:
        st.sidebar.subheader("üéØ Solu√ß√£o:")

        # Mapeamento de vari√°veis para nota√ß√£o mais amig√°vel
        mapa_variaveis = {
            'x_1': 'x',
            'x_2': 'y',
            'x_3': 'z',
        }

        for i, s in enumerate(sol):
            sol_str = str(s)

            # --- IN√çCIO DA ALTERA√á√ÉO ---
            # Remove a palavra "(livre)" e espa√ßos extras
            sol_str = sol_str.replace('(livre)', '').strip()
            # --- FIM DA ALTERA√á√ÉO ---

            # Determina√ß√£o da vari√°vel dependente
            if i == 0:
                var_dependente = 'x'
            elif i == 1:
                var_dependente = 'y'
            elif i == 2:
                var_dependente = 'z'
            else:
                var_dependente = f'x_{i+1}'

            # Formata√ß√£o da solu√ß√£o
            sol_formatada = sol_str
            for var_antiga, var_nova in mapa_variaveis.items():
                sol_formatada = sol_formatada.replace(var_antiga, var_nova)

            if not sol_formatada.startswith(var_dependente + ' ='):
                sol_formatada = f"{var_dependente} = {sol_formatada}"

            st.sidebar.write(f"**{sol_formatada.strip()}**")

# =============================================================================
# INTERFACE PRINCIPAL - VISUALIZA√á√ÉO E RESULTADOS
# =============================================================================

col1, col2 = st.columns([1, 1])

# -------------------------
# COLUNA 1: SISTEMA DE EQUA√á√ïES
# -------------------------

with col1:
    st.header("üìù Sistema de Equa√ß√µes")
    st.markdown("""
    As equa√ß√µes inseridas s√£o exibidas abaixo.
    Cada equa√ß√£o representa um plano no espa√ßo tridimensional.
    """)
    
    # Montagem da matriz para exibi√ß√£o
    matriz_list_display = [
        [a1, b1, c1, d1],
        [a2, b2, c2, d2], 
        [a3, b3, c3, d3]
    ]
    matriz_display = np.array(matriz_list_display, dtype=float)

    # Formata√ß√£o das equa√ß√µes individuais
    eq1_str = formatar_equacao_latex(a1, b1, c1, d1)
    eq2_str = formatar_equacao_latex(a2, b2, c2, d2)
    eq3_str = formatar_equacao_latex(a3, b3, c3, d3)
    
    # Sistema de equa√ß√µes em LaTeX
    latex_equacoes = f"""
    $$
    \\begin{{cases}}
    {eq1_str} \\\\
    {eq2_str} \\\\
    {eq3_str}
    \\end{{cases}}
    $$
    """
    
    st.markdown(latex_equacoes, unsafe_allow_html=True)

# -------------------------
# COLUNA 2: VISUALIZA√á√ÉO E AN√ÅLISE
# -------------------------

with col2:
    st.header("üìä Visualiza√ß√£o e Resultados")
    
    if 'sistema_resolvido' in st.session_state and st.session_state['sistema_resolvido']:
        # Recupera√ß√£o dos dados da sess√£o
        matriz_inicial = st.session_state['matriz_inicial']
        steps_data = st.session_state['steps_data']
        solution_point = st.session_state['solution_point']
        desc = st.session_state['solucao_desc']

        # Exibi√ß√£o da matriz aumentada inicial
        st.subheader("Matriz Aumentada do Sistema:")
        st.markdown("""
        A matriz aumentada combina os coeficientes das vari√°veis com os termos independentes,
        separados por uma linha vertical.
        """)
        latex_matriz = formatar_matriz_latex(matriz_inicial)
        st.markdown(latex_matriz, unsafe_allow_html=True)
        
        # Visualiza√ß√£o passo a passo
        st.subheader("üåê Visualiza√ß√£o 3D dos Planos - Passo a Passo:")
        st.markdown("""
        Cada aba mostra um passo da elimina√ß√£o gaussiana e como os planos se transformam geometricamente.
        """)
        
        if len(steps_data) > 0:
            # Cria√ß√£o das abas para cada passo
            tab_names = [f"Passo {i+1}" for i in range(len(steps_data))]
            tabs = st.tabs(tab_names)
            
            prev_matriz = None
            for i, (tab, step_info) in enumerate(zip(tabs, steps_data)):
                with tab:
                    # Obten√ß√£o da matriz do passo atual
                    matriz_passo = step_info.get('matriz_float', step_info.get('matriz'))
                    
                    st.markdown(f"**{step_info['step_name']}**")

                    # Exibi√ß√£o da transforma√ß√£o matricial
                    if i > 0:
                        display_step_with_annotations(matriz_passo, prev_matriz, step_info)
                    else:
                        st.markdown("**Matriz inicial:**")
                        latex_passo = formatar_matriz_latex(matriz_passo)
                        st.markdown(latex_passo, unsafe_allow_html=True)
                    
                    st.markdown("---")
                    
                    # Visualiza√ß√£o 3D
                    st.markdown("**Visualiza√ß√£o 3D dos Planos:**")
                    try:
                        plot_sol_point = None
                        if "determinado" in desc.lower() and i == len(steps_data) - 1:
                            plot_sol_point = solution_point
                            
                        fig = plotar_planos_3d(
                            matriz_passo, 
                            step=step_info['step_name'], 
                            solution_point=plot_sol_point
                        )
                        
                        if fig:
                            st.plotly_chart(fig, use_container_width=True)
                        else:
                            st.info("N√£o foi poss√≠vel gerar a visualiza√ß√£o 3D para este passo.")
                            
                    except Exception as e:
                        st.error(f"Erro na visualiza√ß√£o: {str(e)}")
                        st.info("Tentando visualizar apenas as equa√ß√µes v√°lidas...")
                        
                        try:
                            # Filtro de equa√ß√µes v√°lidas (n√£o degeneradas)
                            matriz_filtrada = [
                                row for row in matriz_passo 
                                if not np.allclose(row[:3], 0, atol=1e-10)
                            ]
                            
                            if len(matriz_filtrada) > 0:
                                fig = plotar_planos_3d(
                                    np.array(matriz_filtrada), 
                                    step=step_info['step_name'], 
                                    solution_point=plot_sol_point
                                )
                                if fig:
                                    st.plotly_chart(fig, use_container_width=True)
                        except:
                            st.warning("N√£o foi poss√≠vel gerar visualiza√ß√£o para este passo.")

                    # Atualiza√ß√£o para o pr√≥ximo ciclo
                    prev_matriz = matriz_passo
            
        # Se√ß√£o expand√≠vel com processo detalhado        
        with st.expander("üîç Ver Processo de Resolu√ß√£o Detalhado"):
            st.subheader("An√°lise Completa da Elimina√ß√£o Gaussiana:")
            st.markdown("""
            Esta se√ß√£o mostra todos os passos da elimina√ß√£o gaussiana de forma sequencial,
            incluindo as opera√ß√µes matriciais.
            """)
            
            prev_matriz_expand = None
            for i, step_info in enumerate(steps_data):
                matriz_passo_expand = step_info.get('matriz_float', step_info.get('matriz'))
                
                st.markdown(f"**Passo {i+1}: {step_info['step_name']}**")
                
                if i > 0:
                    display_step_with_annotations(matriz_passo_expand, prev_matriz_expand, step_info)
                else:
                    st.markdown(formatar_matriz_latex(matriz_passo_expand), unsafe_allow_html=True)
                    
                st.markdown("---")
                prev_matriz_expand = matriz_passo_expand
                
    else:
        st.info("""
        **Como usar:**
        1. Insira os coeficientes das equa√ß√µes na barra lateral
        2. Clique em 'Resolver Sistema' 
        3. Visualize o processo passo a passo e os resultados aqui
        
        A aplica√ß√£o mostrar√° tanto a resolu√ß√£o alg√©brica quanto a interpreta√ß√£o geom√©trica 3D.
        """)

# =============================================================================
# SE√á√ÉO DE AJUDA E DOCUMENTA√á√ÉO
# =============================================================================

st.sidebar.markdown("---")
st.sidebar.header("üìö Ajuda")

with st.sidebar.expander("Como usar a aplica√ß√£o"):
    st.markdown("""
    ### üîß **Entrada de Dados**
    - Insira os coeficientes para cada equa√ß√£o no formato **ax + by + cz = d**
    - Use n√∫meros decimais (ex: 1.5, -2.7)
    - Deixe coeficientes como zero para vari√°veis que n√£o aparecem na equa√ß√£o
    
    ### üìä **Interpreta√ß√£o dos Resultados**
    - **SPD (Sistema Poss√≠vel Determinado)**: Uma √∫nica solu√ß√£o - os tr√™s planos se intersectam em um ponto
    - **SPI (Sistema Poss√≠vel Indeterminado)**: Infinitas solu√ß√µes - os planos se intersectam em uma linha ou s√£o coincidentes
    - **SI (Sistema Imposs√≠vel)**: Nenhuma solu√ß√£o - os planos s√£o paralelos ou n√£o t√™m interse√ß√£o comum
    
    ### üåê **Visualiza√ß√£o 3D**
    - Cada aba mostra um passo da elimina√ß√£o gaussiana
    - Os planos 3D s√£o atualizados conforme a matriz √© transformada
    - Observe como as opera√ß√µes simplificam o sistema geometricamente
    - No resultado final (SPD), o ponto de interse√ß√£o √© destacado em dourado
    """)

with st.sidebar.expander("Exemplos de sistemas"):
    st.markdown("""
    ### üéØ **Sistema com Solu√ß√£o √önica (SPD)**
    ```
    x + y + z = 6
    x - y + 2z = 5  
    x - y - 3z = -10
    ```
    
    ### ‚ôæÔ∏è **Sistema com Infinitas Solu√ß√µes (SPI)**
    ```
    x + y - 2z = 6
    2x + 3y + z = 8
    0x + 0y + 0z = 0
    ```
    
    ### ‚ùå **Sistema Imposs√≠vel (SI)**
    ```  
    x + y + z = 1
    x + y + z = 2
    2x + 2y + 2z = 5
    ```
    """)

with st.sidebar.expander("Sobre a matem√°tica"):
    st.markdown("""
    ### üìê **Interpreta√ß√£o Geom√©trica**
    - Cada equa√ß√£o linear representa um **plano** no espa√ßo 3D
    - A solu√ß√£o do sistema √© a **interse√ß√£o** desses planos
    - Tr√™s planos podem se intersectar de diferentes formas:
      - **Um ponto** (solu√ß√£o √∫nica)
      - **Uma linha** (infinitas solu√ß√µes)
      - **Conjunto vazio** (sem solu√ß√£o)
    
    ### üî¢ **M√©todo de Elimina√ß√£o Gaussiana**
    1. **Escalonamento**: Transformar em matriz triangular superior
    2. **Pivotamento**: Escolher elementos n√£o-nulos como piv√¥s
    3. **Opera√ß√µes elementares**:
       - Trocar linhas
       - Multiplicar linha por constante n√£o-nula
       - Somar m√∫ltiplo de uma linha a outra
    """)

# =============================================================================
# RODAP√â E INFORMA√á√ïES FINAIS
# =============================================================================

st.markdown("---")
st.markdown("""
<div style='text-align: center; padding: 20px;'>
    <h3>üî¢ Resolvedor de Sistemas Lineares 3D</h3>
    <p><strong>Desenvolvido com Streamlit </strong></p>
    <p>‚ú® <em>Ferramenta educacional para a compreens√£o visual de sistemas lineares</em> ‚ú®</p>
</div>
""", unsafe_allow_html=True)
